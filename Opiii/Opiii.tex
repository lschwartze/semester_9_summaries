\documentclass[a4paper, 12pt]{article}

\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath,amssymb}
\usepackage[explicit]{titlesec}
\usepackage{ulem}
\usepackage[onehalfspacing]{setspace}
\usepackage{amsthm}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section] % reset theorem numbering for each chapter

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition} % definition numbers are dependent on theorem numbers
\theoremstyle{lemma}
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

\theoremstyle{corollary}
\newtheorem{corollary}[theorem]{Corollary}

\theoremstyle{example}
\newtheorem{example}[theorem]{Example}

\titleformat{\subsection}
{\small}{\thesubsection}{1em}{\uline{#1}}
\begin{document}
	\begin{titlepage} 
		\title{Opiii}
		\clearpage\maketitle
		\thispagestyle{empty}
	\end{titlepage}
	\tableofcontents
	\newpage
	\section{Dynamic Networks}
	Dynamic graph networks are graph networks that change over time. Communication is in synchronous, asynchronous or semi-synchronous rounds. Additionally shared memory is possible. Network elements may be failure-free or failure-prone. A classical example are \underline{mobile ad-hoc networks}. Those are temporary interconnection networks of mobile wireless nodes without a fixed infrastructure. Communication happens whenever mobile nodes come within the wireless range of each other.
	\begin{example}
		In mobile ad hoc networks, one may want to colour the graph or maintain a routing mechanism for communication to any particular destination in the network.
	\end{example}
	\subsection{Almost constant message-passing vertex colouring in a tree}
	Let $T$ be a tree network with $n$ labelled vertices in $[n]$. Colouring the graph can be done in almost constant, i.e. in $\log^*$ time.
	\begin{definition}
		$\log^*(x)$ is defined as the number of $\log$ functions that need to be applied to $x$ such that the result is at most 1. E.g. $\log^*(16) = 3$ and $\log^*2^{65536} = 5$.
	\end{definition}
	\begin{enumerate}
		\item begin by rooting the tree at vertex $0$. This defines an order on the tree
		\item each parent sends its number to all of its children
		\item each child computes the smallest index $i$ where its number differs from the parent's number. It is important to note that this can be done in constant time with suitable hardware
		\item It computes a new ID for itself consisting of a trailing bit corresponding to the bit where IDs disagreed. The new ID begins with the binary representation of the digit where the Ids differed.
		\item the new ID is now only $\log\log n$ bits long. This is repeated until there are only six distinct numbers left. This takes $\log^*$ rounds each taking only constant time.
		\item each parent sends its number to its children which relabel themselves accordingly
		\item This is repeated another time and the IDs are taken $\mod 3$ resulting in a three colourin
	\end{enumerate}
	\begin{definition}
		The collection of the initial states of all nodes in the $r$-neighbourhood of a node $v$ is the $r$-hop view of $v$.
	\end{definition}
	\begin{definition}
		Let $\mathcal{G}$ be a family of network graphs. The $r$-neighbourhood graph $N_r(\mathcal{G})$ is defined as follows:\\
		The node set is the set of all possible labelled $r$-neighbourhoods (i.e. all possible $r$-hop views). There is an edge between tow labelled $r$-neighbourhoods $V_r$ and $V_r'$ if $V_r$ and $V_r'$ can be the $r$-hop views of adjacent nodes.
	\end{definition}
	\begin{lemma}
		For a given family of network graphs $\mathcal{G}$ there is an $r$-round algorithm that colours graphs of $\mathcal{G}$ with $c$ colours of the chromatic number of the neighbourhood graph is $\chi(N_r(\mathcal{G})) \leq c$.
	\end{lemma}
	\begin{definition}
		We define a directed graph $B_k$ which is closely related to the neighbourhood graph. The vertex set is made up of all $k$-tuples consisting increasing node labels. For two nodes $\alpha = (\alpha_1, ..., \alpha_k)$ and $\beta = (\beta_1, ..., \beta_k)$ there is an edge from $\alpha$ to $\beta$ if $\forall i$ it holds that $\beta_i = \alpha_{i+1}$.
	\end{definition}
	\begin{lemma}
		Viewed as an undirected graph, $B_{2r+1}$ is a subgraph of the $r$-neighbourhood graph of directed rings with $n$ nodes.
	\end{lemma}
	\begin{lemma}
		If $n>k$ the graph $B_{k+1}$ can be defined as the line graph $\mathcal{L}(B_k)$ of $B_k$.
	\end{lemma}
	\begin{lemma}
		It holds that \[\chi(\mathcal{L}(G)) \geq \log_2(\chi(G))\]
	\end{lemma}
	\begin{lemma}
		For all $n\geq 1$ it holds that $\chi(B_1) = n$. Further for $n\geq k \geq 2$ it holds that $\chi(B_k) \geq \log^{(k-1)} n$.
	\end{lemma}
	\begin{theorem}
		Every deterministic distributed algorithm to colour a directed ring with at most 3 colours needs at least $\log^*(\frac{n}{2}) - 1$ rounds.
	\end{theorem}
	\begin{corollary}
		Every deterministic distributed algorithm to compute a maximal independent set on a directed ring needs at least $\log^*(\frac{n}{2}) - \mathcal{O}(1)$ rounds.
	\end{corollary}
	\subsection{MIS}
	The following randomized algorithm gives a good solution to the maximum independent set.
	\begin{enumerate}
		\item the algorithm operates in synchronous rounds grouped into phases
		\item each node marks itself with probability $\frac{1}{2d(v)}$
		\item if no higher degree neighbour of $v$ is marked, node $v$ unmarks itself again
		\item delete all nodes that joined the MIS and their neighbours as the cannot join the MIS any more
	\end{enumerate}
	\begin{lemma}
		A node $v$ joins the MIS in step 3 with probability $p \geq \frac{1}{4d(v)}$
	\end{lemma}
	\begin{lemma}
		A node is called good if \[\sum_{w \in N(v)} \frac{1}{2d(v)} \geq \frac{1}{6}\]
		A good node will be removed in Step 4 with probability $p \geq \frac{1}{36}$.
	\end{lemma}
	\begin{lemma}
		An edge is called bad if both its endvertices are bad. Otherwise it's called good. At any time at least half of the edges are good.
	\end{lemma}
	\begin{lemma}
		A bad node has out-degree at least twice its in-degree.
	\end{lemma}
	\begin{lemma}
		The algorithm terminates in expectation in $\mathcal{O}(\log n)$ rounds.
	\end{lemma}
	\section{Consensus}
	In a distributed system with each node starting with input $x_i$, we speak of consensus if an algorithm can achieve the following properties 
	\begin{enumerate}
		\item Agreement: all alive nodes decide on a single value $x$
		\item Validity: the decided value $x$ is one of the initial inputs
		\item Termination: each vertex terminates at some point (either voting for one value or crashing)
	\end{enumerate}
	The following randomized consensus algorithm works in an asynchronous setting with less than half the nodes crashing
	\begin{enumerate}
		\item input bit $v_i \in \{0,1\}$, $round = 1$, decided = false
		\item broadcast $(v_i, round)$
		\item while true
		\item wait until majority of messages of current round arrived
		\item if all messages contain the same value $v$:  
		\item propose $(v,round)$, decided = true
		\item else: 
		\item propose $(\bot, round)$ //$\bot$ is a signal of disagreement
		\item end if 
		\item wait until a majority of proposals of current round arrived
		\item if all messages propose the same value $v$:
		\item $v_i = v$, decide = true
		\item else if there is at least one proposal for $v$:
		\item $v_i = v$
		\item else:
		\item choose $v_i$ uniformly at random
		\item end if
		\item $round = round +1$
		\item broadcast $(v_i,round)$
		\item end while
	\end{enumerate}
	\begin{theorem}
		The above algorithm satisfies validity, termination and comes to an agreement. In expectation it takes exponential time.
	\end{theorem}
	\subsection{shared coin}
	The following algorithm allows a dynamic network to use the same coin for all vertices at the same time. Here $f$ is the number of nodes that can turn byzantine. It should hold that $f \leq \frac{n}{3}$.
	\begin{enumerate}
		\item choose local coin $c_u = 0$ with probability $\frac{1}{n}$
		\item broadcast $c_u$
		\item wait for $n-f$ coins and store them in the local coin set $C_u$
		\item broadcast $C_u$
		\item wait for $n-f$ coin sets
		\item if at least one coin is 0 among all coins in $C_u$:
		\item return 0
		\item return 1
		\item end if
	\end{enumerate}
	\subsection{byzantine consensus}
	\begin{definition}
		A node which can have arbitrary or malicious behaviour is called \underline{byzantine}. This includes not sending messages, sending wrong messages, sending different messages to different neighbours and many more. A node that is not byzantine is called \underline{correct} or \underline{truthful}.
	\end{definition}
	The following probabilistic algorithm achieves consensus in an asynchronous setting with $<\frac{n}{9}$ byzantine nodes.
	\begin{enumerate}
		\item $x_i \in \{0,1\}$, $r = 1$, decided = false
		\item propose($x_i,r$)
		\item while not decided
		\item wait until $n-f$ proposals of current round $r$ arrived
		\item if at least $n-2f$ proposals contain the same value $x$: $x_i=x$ decided = true
		\item elseif at least $n-4f$ proposals contain the same value $x$: $x_i=x$
		\item else: choose $x_i$ randomly with $\mathbb{P}[x_i=0] = \mathbb{P}[x_i=1] = \frac{1}{2}$
		\item endif
		\item $r = r+1$, propose($x_i, r$)
		\item endwhile
		\item decision = $x_i$
	\end{enumerate}
	\begin{lemma}
		Let $f < \frac{n}{9}$. If a correct node chooses value $x$ in line 6, then no other correct node chooses value $y\neq x$ in line 6.
	\end{lemma}
	\begin{theorem}
		The algorithm solves binary agreement for up to $f<\frac{n}{9}$ byzantine nodes. 
	\end{theorem}
	\begin{definition}
		$N[u] = N(u) \cup \{u\}$
	\end{definition}
\section{Dominating Set}
	The following algorithm gives an approximation to a minimal dominating set. To this end, we colour vertices white in the beginning, black if they are added to the dominating set $S$ and grey if they are covered by a neighbour in $S$. For a vertex $u$ we define $W(u) = \{v \in N[u]\mid v \text{ is white}\}$.
	\begin{enumerate}
		\item while $v$ has white neighbours
		\item compute $\left|W(v)\right|$ and send it to all neighbours at distance at most 2
		\item if $\left|W(v)\right|$ is largest among neighbours of distance 2
		\item join $S$
		\item endif
		\item endwhile
	\end{enumerate}
	\begin{theorem}
		Let $S^*$ be the optimal dominating set and $S$ the one returned by the algorithm. Then $\frac{\left|S\right|}{\left|S^*\right|} \leq \ln \Delta + 2$. The algorithm takes $\Theta(n)$ rounds.
	\end{theorem}
	In the following we try to push this runtime to sublinear.
	\subsection{Fast Dominating Set Algorithm}
	\begin{enumerate}
		\item $W(v) = N[v]$, $w(v) = \left|W(v)\right|$
		\item while $W(v) \neq \varnothing$
		\item $w'(v) = w(v)$ rounded down to the nearest power of 2
		\item if $w(v) = \max_{u \in N_2(v)} w'(u)$ then $v.active = true$
		\item else $v.active = false$
		\item endif
		\item compute active neighbours $a(v) = \{u \in N(v) \mid u.active\}$
		\item $v.candidate = false$
		\item if $v.active = true$ then
		\item $v.candidate = true$ with probability $\frac{1}{\max_{u \in W(v)}a(u)}$
		\item endif
		\item compute $c(v) = \left|\{u \in W(v) \mid u.candidate\}\right|$
		\item if $v.candidate$ and $\sum_{u \in W(v)} c(u) \leq 3w(v)$ then
		\item node $v$ joins dominating set
		\item endif
		\item update $W$, $w$
		\item endwhile
	\end{enumerate}
	\begin{theorem}
		The algorithm computes a dominating set of size at most $(6\ln \Delta + 12)\left|S^*\right|$.
	\end{theorem}
	\begin{lemma}
		Consider an iteration of the while loop. Suppose that a node $u$ is white and that $2a(u) \geq \max_{v \in C(u)} \max_{y \in W(y)} a(y)$ where \[C(u) = \{v \in N(u) \mid v.candidate\}\] Then the probability that $u$ becomes dominated in this iteration is larger than $\frac{1}{9}$.
	\end{lemma}
	\section{maximal matching}
	This section introduces a new technique called rounding. The idea is to solve a given integral problem as a continuous problem and then rounding the results to the nearest integer. This often allows for polylogarithmic time complexity.
	\begin{definition}
		A maximal matching is a subset $S$ of edges s.t. no vertex has two incident edges in $S$. Furthermore, there are no edges $e \in E\setminus S$ that can be added to $S$ without breaking the first condition. 
	\end{definition}
	This problem is a typical integer linear problem, i.e. one where variables $x_e$ for $e \in E$ are in $\{0,1\}$. The idea is now to allow continuous variables and fix the result by rounding. A non-integral result is called a fractional matching.
	\begin{definition}
		In a fractional matching we call a vertex $v$ loose if $c_v = \sum_{e \in E(v)} x_e \leq \frac{1}{2}$. An edge is called loose if both its vertices are loose. We call a fractional matching $f$-fraction if $c_v \geq f$ $\forall v \in V$.
	\end{definition}
	The following algorithm runs in $\mathcal{O}(\log n)$ time and yields a 4-approximation to for a fractional matching.\\
	\begin{enumerate}
		\item $x_e = 2^{-(\lceil\log \Delta \rceil)}$
		\item while both endpoints of $e$ are loose:
		\item $x_e = 2x_e$
		\item endwhile
	\end{enumerate}
	\begin{theorem}
		The algorithm computes a 4-approximation $\frac{1}{\Delta}$-fractional matching in $\mathcal{O}(\log \Delta)$ time.
	\end{theorem}
	The idea is now to get rid of the fractional edges. This works by starting to either multiply all edges of value $\frac{1}{\Delta}$ by a factor of 2 or by rounding them down to 0. In the next step this is done for edges of value $\frac{2}{\Delta}$ and so on.
	\begin{definition}
		We define the subgraph $G_f$ as the graph induced by all edges of value $f$ in $G$.
	\end{definition}
	\begin{definition}
		Rounding the graph $G_f$ means to identify a subset of edges of value $f$ in $E_f$ which will be doubled. All other edges in (which are also of value $f$!) will be assigned value 0. The resulting graph should still be a valid $2f$-fractional matching.
	\end{definition}
	\begin{definition}
		A perfect rounding of a graph $G$ is a rounding of the graph such that for all nodes $v$ half of its edges are assigned twice its value and the other half 0. Notice that $c_v$ and the size of the matching remain unchanged.
	\end{definition}
	We start by introducing the idea for bipartite graphs. For this, we need to construct a 2-decomposition of the graph $G_f$.
	\begin{definition}
		For a graph $G$ we define a decomposition $G'$ of $G$ by copying each vertex $v$ $\frac{d(v)}{2}$ times. The edges incident to $v$ are distributed among all these copies such that each copy has degree 2 (in the case that $d(v)$ is odd, one copy may have degree 1).
	\end{definition}
	Note that in $G'$ each vertex $v$ has $d(v) \in \{1,2\}$. I.e. $G'$ is a disjoint union of cycles and paths.
	\begin{definition}
		A cycle or path is called short if its length is at most $l = 24\log \Delta$ and long otherwise.
	\end{definition}
	Since we assumed that the starting graph is bipartite, all cycles are even. Therefore we would want the edge values to be raised and dropped alternately along the cycle. This is a perfect rounding. If the cycle is short, the following algorithm achieves this in $\mathcal{O}(\log \Delta)$.
	\begin{enumerate}
		\item Orient the cycle in one direction
		\item if $e$ goes from a node with colour 1 to colour 2:
		\item $x_e := 2x_e$
		\item else: $x_e := 0$
	\end{enumerate}
	In a long cycle the first line is not easy to solve. Therefore, we contend ourselves with a common direction only on subpaths of length at least $l$ on long cycles.
	\begin{definition}
		Consider a cycle with an orientation of each edge. A maximal directed path is a directed path that can not be extended since both neighbouring edges have inconsistent orientation.
	\end{definition}
	Starting from a random orientation we can achieve long directed paths by determining the length of a subpath and compute the length of the subpath it points towards. By flipping the edges of the shorter path, we create a longer directed path.
	\begin{enumerate}
		\item orient $e$ arbitrarily
		\item for $i=1,...,\log(l)$:
		\item compute the length of the path pointing in the opposite direction and flip the edges of the shorter path
		\item endfor
	\end{enumerate}
	Since we can now compute long subpaths of long cycles, we discuss rounding of long cycles in the next step.
	\begin{enumerate}
		\item compute long paths
		\item if $e$ is a boundary edge or goes from a node of colour 2 to colour 1: $x_e := 0$
		\item else: $x_e := 2x_e$
	\end{enumerate}
	\begin{lemma}
		Rounding long cycles leads to a loss of $\leq \frac{3}{l} \sum_{e \in E} x_e$.
	\end{lemma}
	Obviously the same approach works for long paths.\\
	The algorithm for short paths is a bit more complicated.
	\begin{enumerate}
		\item orient the graph with start node $s$ and end note $t$
		\item if $e$ is first edge:
		\item if $s$ is tight (\textit{not loose}): $x_e := 0$
		\item else: $x_e := 2x_e$
		\item else if $e$ is the last edge:
		\item if $t$ is tight: $x_e := 0$
		\item else: $x_e := 2x_e$
		\item else if $e$ is an even edge: $x_e := 0$
		\item else: $x_e := 2x_e$ 
	\end{enumerate}
	\begin{lemma}
		Rounding short paths results in a loss $\leq 4f \sum_{e \in E} x_e$
	\end{lemma}
	\begin{lemma}
		In the rounding step going from an $f$-fractional matching to a $2f$-fractional matching the matching decreases by a factor of at most $(1-\frac{3}{l} - 4f)$ and the rounding step takes $\mathcal{O}(\Delta)$ time.
	\end{lemma}
	\begin{lemma}
		This results in a $\frac{1}{16}$-fractional matching which is a constant factor smaller than the initial $\frac{1}{\Delta}$ matching. 
	\end{lemma}
	\begin{lemma}
		A constant factor approximation 16-fractional matching can be computed in $\mathcal{O}(\log^2 \Delta)$ in a 2-coloured bipartite graph.
	\end{lemma}
	\begin{lemma}
		A constant factor approximation matching can be computed in $\mathcal{O}(\log^2 \Delta)$ time in a 2-coloured bipartite graph with maximum degree $\Delta$.
	\end{lemma}
\end{document}